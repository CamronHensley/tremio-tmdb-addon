/**
 * Nightly Update Script (SIMPLIFIED)
 *
 * Runs via GitHub Actions at midnight UTC
 * Fetches fresh data from TMDB and stores in Netlify Blobs
 */

require('dotenv').config();

const { getStore } = require('@netlify/blobs');
const TMDBClient = require('../lib/tmdb-client');
const WikidataClient = require('../lib/wikidata-client');
const FanartClient = require('../lib/fanart-client');
const OMDbClient = require('../lib/omdb-client');
const { GENRES, MOVIES_PER_GENRE, STREAMING_SERVICES, getCurrentSeason, SEASONAL_HOLIDAYS } = require('../lib/constants');

// Validate environment variables
function validateEnv() {
  const required = ['TMDB_API_KEY', 'NETLIFY_ACCESS_TOKEN', 'NETLIFY_SITE_ID'];
  const missing = required.filter(key => !process.env[key]);

  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
  }
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Main update function
async function runUpdate() {
  console.log('üé¨ Starting nightly TMDB catalog update...');
  console.log(`üìÖ Date: ${new Date().toISOString()}`);

  validateEnv();

  const tmdb = new TMDBClient(process.env.TMDB_API_KEY);
  const allGenreCodes = Object.keys(GENRES);

  // Get store for Netlify Blobs
  const store = getStore({
    name: 'tmdb-catalog',
    siteID: process.env.NETLIFY_SITE_ID,
    token: process.env.NETLIFY_ACCESS_TOKEN
  });

  // STEP 1: Fetch movies from TMDB
  console.log('\nüîç Fetching from TMDB...');
  console.log(`üìÑ Fetching from BOTH top_rated (all-time classics) AND popular (recent hits)`);
  console.log(`üìÑ 15 pages each = ~600 movies per genre to overcome recency bias`);

  const moviesByGenre = {};
  const usedMovieIds = new Set(); // Global deduplication

  for (const genreCode of allGenreCodes) {
    const genre = GENRES[genreCode];
    console.log(`  ‚Üí ${genre.name}...`);

    try {
      let movies = [];

      // Handle seasonal genre differently
      if (genre.isSeasonal) {
        const currentSeason = getCurrentSeason();
        const seasonalHoliday = SEASONAL_HOLIDAYS[currentSeason.key];

        console.log(`    ‚Üí Current season: ${seasonalHoliday.name}`);

        // Fetch seasonal movies using keywords - expanded to 15 pages
        const seasonalMovies = [];
        for (let page = 1; page <= 15; page++) {
          const response = await tmdb.discoverSeasonalMovies(
            seasonalHoliday.tmdbKeywordIds,
            {
              page,
              sortBy: 'popularity.desc',
              minVotes: 100,
              excludeGenres: seasonalHoliday.excludeGenres || []
            }
          );
          if (response.results && response.results.length > 0) {
            seasonalMovies.push(...response.results);
          }
          await sleep(200);
        }
        movies = seasonalMovies;

      } else {
        // DUAL FETCH STRATEGY: Top-rated (classics) + Popular (recent)
        console.log(`    ‚Üí Fetching top-rated (all-time classics)...`);
        const topRated = await tmdb.fetchGenreMovies(
          genre.id,
          [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
          'vote_average.desc',
          { minVotes: 500 } // Higher threshold for classics
        );

        console.log(`    ‚Üí Fetching popular (recent hits)...`);
        const popular = await tmdb.fetchGenreMovies(
          genre.id,
          [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
          'popularity.desc',
          { minVotes: 100 }
        );

        // Merge and deduplicate by TMDB ID
        const movieMap = new Map();
        [...topRated, ...popular].forEach(movie => {
          if (!movieMap.has(movie.id)) {
            movieMap.set(movie.id, movie);
          }
        });
        movies = Array.from(movieMap.values());

        console.log(`    ‚Üí Combined: ${topRated.length} top-rated + ${popular.length} popular = ${movies.length} unique`);
      }

      // Filter: basic quality filter + not already used
      const filtered = movies.filter(movie => {
        // Skip if already used in another genre
        if (usedMovieIds.has(movie.id)) return false;

        // Quality filter (for all-time popular movies)
        return (
          movie.vote_count >= 100 &&
          movie.popularity >= 5
        );
      });

      // Sort by popularity (will cache ALL, not just top 100)
      const sorted = filtered.sort((a, b) => b.popularity - a.popularity);

      // Mark these IDs as used for caching
      sorted.forEach(movie => usedMovieIds.add(movie.id));

      moviesByGenre[genreCode] = sorted;
      console.log(`    ‚úì Selected ${sorted.length} movies (from ${movies.length} fetched, ${filtered.length} after filter)`);

    } catch (error) {
      console.error(`    ‚úó Failed: ${error.message}`);
      moviesByGenre[genreCode] = [];
    }

    await sleep(200); // Rate limit courtesy delay
  }

  console.log(`\nüìä Total API requests for discovery: ${tmdb.getRequestCount()}`);
  console.log(`üéØ Total unique movies selected: ${usedMovieIds.size}`);

  // STEP 2: Fetch full details for all selected movies
  console.log('\nüì• Fetching movie details...');
  const genresWithDetails = {};

  for (const genreCode of allGenreCodes) {
    const movies = moviesByGenre[genreCode] || [];
    const movieIds = movies.map(m => m.id);

    console.log(`  ‚Üí ${GENRES[genreCode].name}: ${movies.length} movies`);

    if (movieIds.length === 0) {
      genresWithDetails[genreCode] = [];
      continue;
    }

    // Fetch details in batches
    const details = await tmdb.fetchMovieDetailsBatch(movieIds);

    // Convert to Stremio format
    const moviesWithMeta = details
      .map(movie => TMDBClient.toStremioMeta(movie))
      .filter(meta => meta !== null);

    genresWithDetails[genreCode] = moviesWithMeta;

    console.log(`    ‚úì Got details for ${genresWithDetails[genreCode].length} movies`);
  }

  console.log(`\nüìä Total API requests: ${tmdb.getRequestCount()}`);

  // STEP 3: Fetch IMDb ratings from OMDb (optional, with persistent caching)
  console.log('\n‚≠ê Fetching IMDb ratings from OMDb...');
  const omdbApiKey = process.env.OMDB_API_KEY;
  let imdbRatingsMap = new Map();
  let omdb = null;

  // OMDb cache is now built by separate cache-omdb.js script in workflow
  // This just loads the cached ratings for use in catalog building
  if (omdbApiKey) {
    // Load existing IMDb ratings cache from Netlify Blobs
    console.log('  ‚Üí Loading cached IMDb ratings from Netlify Blobs...');
    let cachedRatings = null;
    try {
      cachedRatings = await store.get('imdb-ratings', { type: 'json' });
      if (cachedRatings) {
        const cacheSize = Object.keys(cachedRatings).length;
        console.log(`  ‚úì Loaded ${cacheSize} cached IMDb ratings`);
      } else {
        console.log('  ‚Üí No cached ratings found, starting fresh');
      }
    } catch (error) {
      console.log('  ‚Üí No cached ratings found, starting fresh');
    }

    // Initialize OMDb client with persistent cache
    const persistentCache = OMDbClient.loadPersistentCache(cachedRatings);
    omdb = new OMDbClient(omdbApiKey, persistentCache);

    // Collect IMDb IDs - PRIORITIZE top movies per genre first
    // This ensures we fetch ratings for movies that will actually be displayed
    const priorityImdbIds = [];
    const otherImdbIds = [];

    for (const genreCode of allGenreCodes) {
      const movies = genresWithDetails[genreCode] || [];

      movies.forEach((movie, index) => {
        const imdbUrl = movie.links?.imdb;
        if (imdbUrl) {
          const match = imdbUrl.match(/tt\d+/);
          if (match) {
            const imdbId = match[0];
            // Top 100 movies per genre get priority (will be in display catalog)
            if (index < MOVIES_PER_GENRE) {
              priorityImdbIds.push(imdbId);
            } else {
              otherImdbIds.push(imdbId);
            }
          }
        }
      });
    }

    // Fetch priority movies first, then others (so we don't waste API calls on low-priority movies)
    const imdbIds = [...priorityImdbIds, ...otherImdbIds];

    console.log(`  ‚Üí Found ${imdbIds.length} total movies (${priorityImdbIds.length} priority, ${otherImdbIds.length} overflow)`);

    if (imdbIds.length > 0) {
      // Fetch ratings in batch (will use cache for existing movies)
      imdbRatingsMap = await omdb.getMovieRatingsBatch(imdbIds);

      console.log(`\nüéØ OMDb results: ${imdbRatingsMap.size} movies with IMDb ratings`);
      console.log(`üìä OMDb API requests (new only): ${omdb.getRequestCount()}`);
      console.log(`üíæ Cached ratings used: ${imdbRatingsMap.size - omdb.getRequestCount()}`);

      // Save updated cache back to Netlify Blobs
      if (omdb.getNewRatings().size > 0) {
        console.log(`\nüíæ Saving ${omdb.getNewRatings().size} new IMDb ratings to cache...`);
        const mergedCache = OMDbClient.mergeCaches(persistentCache, omdb.getNewRatings());
        await store.setJSON('imdb-ratings', mergedCache);
        console.log(`  ‚úì IMDb ratings cache updated (total: ${Object.keys(mergedCache).length} movies)`);
      } else {
        console.log('\nüíæ No new IMDb ratings to save (all loaded from cache)');
      }

      // Calculate weighted scores and re-sort each genre
      console.log('\nüî¢ Calculating weighted scores and re-sorting by all-time popularity...');
      for (const genreCode of allGenreCodes) {
        const movies = genresWithDetails[genreCode] || [];

        // Add weighted scores to movies
        for (const movie of movies) {
          const imdbUrl = movie.links?.imdb;
          if (imdbUrl) {
            const match = imdbUrl.match(/tt\d+/);
            if (match) {
              const imdbId = match[0];
              const ratingData = imdbRatingsMap.get(imdbId);

              if (ratingData) {
                movie.imdbRating = ratingData.rating;
                movie.imdbVotes = ratingData.votes;
                movie.weightedScore = OMDbClient.calculateWeightedScore(ratingData.rating, ratingData.votes);
              } else {
                movie.weightedScore = 0; // No rating available
              }
            }
          } else {
            movie.weightedScore = 0; // No IMDb ID
          }
        }

        // Re-sort by weighted score (descending)
        movies.sort((a, b) => b.weightedScore - a.weightedScore);

        const withRatings = movies.filter(m => m.weightedScore > 0).length;
        console.log(`  ‚Üí ${GENRES[genreCode].name}: ${withRatings}/${movies.length} movies with IMDb ratings`);
      }
    }
  } else {
    console.log('  ‚äò OMDb API key not provided, using TMDB popularity sorting');
  }

  // STEP 4: Fetch high-quality posters from Fanart.tv (optional)
  console.log('\nüé® Fetching high-quality posters from Fanart.tv...');
  const fanartApiKey = process.env.FANART_API_KEY;
  let fanartPosterMap = new Map();

  if (fanartApiKey) {
    // Load existing Fanart.tv posters cache from Netlify Blobs
    console.log('  ‚Üí Loading cached Fanart.tv posters from Netlify Blobs...');
    let cachedPosters = null;
    try {
      cachedPosters = await store.get('fanart-posters', { type: 'json' });
      if (cachedPosters) {
        const cacheSize = Object.keys(cachedPosters).length;
        console.log(`  ‚úì Loaded ${cacheSize} cached Fanart.tv posters`);
      }
    } catch (error) {
      console.log('  ‚Üí No cached posters found, starting fresh');
    }

    // Initialize Fanart client with persistent cache
    const persistentPosterCache = FanartClient.loadPersistentCache(cachedPosters);
    const fanart = new FanartClient(fanartApiKey, persistentPosterCache);

    // Collect TMDB IDs - PRIORITIZE top movies per genre first
    const priorityTmdbIds = [];
    const otherTmdbIds = [];

    for (const genreCode of allGenreCodes) {
      const movies = genresWithDetails[genreCode] || [];
      movies.forEach((movie, index) => {
        const tmdbId = movie.tmdbId;
        if (tmdbId) {
          if (index < MOVIES_PER_GENRE) {
            priorityTmdbIds.push(tmdbId);
          } else {
            otherTmdbIds.push(tmdbId);
          }
        }
      });
    }

    // Fetch priority movies first, then others
    const tmdbIdsWithPosters = [...priorityTmdbIds, ...otherTmdbIds];
    console.log(`  ‚Üí Checking ${tmdbIdsWithPosters.length} movies (${priorityTmdbIds.length} priority, ${otherTmdbIds.length} overflow)`);

    // Fetch in smaller batches to avoid long waits
    const batchSize = 50;
    for (let i = 0; i < tmdbIdsWithPosters.length; i += batchSize) {
      const batch = tmdbIdsWithPosters.slice(i, i + batchSize);
      console.log(`  ‚Üí Batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(tmdbIdsWithPosters.length / batchSize)}: ${batch.length} movies`);

      const batchResults = await fanart.getMovieArtworkBatch(batch);

      // Merge results
      for (const [tmdbId, posterUrl] of batchResults.entries()) {
        fanartPosterMap.set(tmdbId, posterUrl);
      }

      console.log(`    ‚úì Found ${batchResults.size} Fanart.tv posters in this batch`);
    }

    console.log(`\nüéØ Fanart.tv results: ${fanartPosterMap.size} high-quality posters found`);
    console.log(`üìä Fanart.tv API requests: ${fanart.getRequestCount()}`);

    // Replace TMDB posters with Fanart.tv posters where available
    console.log('\nüñºÔ∏è  Replacing posters with Fanart.tv versions...');
    let replacedCount = 0;
    for (const genreCode of allGenreCodes) {
      const movies = genresWithDetails[genreCode] || [];
      for (const movie of movies) {
        // Extract TMDB ID
        let tmdbId = null;
        if (movie.id.startsWith('tmdb:')) {
          tmdbId = parseInt(movie.id.replace('tmdb:', ''), 10);
        }

        // DISABLED: Fanart.tv images have X-Frame-Options: SAMEORIGIN which blocks loading in Stremio
        // Stremio can't display these images, causing empty placeholders
        // Keep using TMDB posters which have proper CORS headers
        // if (tmdbId && fanartPosterMap.has(tmdbId)) {
        //   // Store original TMDB poster as backup
        //   movie.posterTmdb = movie.poster;
        //   movie.poster = fanartPosterMap.get(tmdbId);
        //   replacedCount++;
        // }
      }
    }
    console.log(`  ‚úì Replaced ${replacedCount} posters with Fanart.tv versions`);

    // Save updated Fanart.tv cache back to Netlify Blobs
    if (fanart.getNewPosters().size > 0) {
      console.log(`\nüíæ Saving ${fanart.getNewPosters().size} new Fanart.tv posters to cache...`);
      const mergedPosterCache = FanartClient.mergeCaches(persistentPosterCache, fanart.getNewPosters());
      await store.setJSON('fanart-posters', mergedPosterCache);
      console.log(`  ‚úì Fanart.tv posters cache updated (total: ${Object.keys(mergedPosterCache).length} movies)`);
    } else {
      console.log('\nüíæ No new Fanart.tv posters to save (all from cache)');
    }
  } else {
    console.log('  ‚äò Fanart.tv API key not provided, using TMDB posters');
  }

  // STEP 5: Query Wikidata for streaming originals
  console.log('\nüåê Querying Wikidata for streaming originals...');

  // Load existing Wikidata cache from Netlify Blobs
  console.log('  ‚Üí Loading cached streaming originals from Netlify Blobs...');
  let cachedStreamingOriginals = null;
  try {
    cachedStreamingOriginals = await store.get('wikidata-streaming', { type: 'json' });
    if (cachedStreamingOriginals) {
      const cacheSize = Object.keys(cachedStreamingOriginals).length;
      console.log(`  ‚úì Loaded ${cacheSize} cached streaming originals`);
    }
  } catch (error) {
    console.log('  ‚Üí No cached streaming originals found, starting fresh');
  }

  // Initialize Wikidata client with persistent cache
  const persistentStreamingCache = WikidataClient.loadPersistentCache(cachedStreamingOriginals);
  const wikidata = new WikidataClient(persistentStreamingCache);

  // Collect TMDB IDs - PRIORITIZE top movies per genre first
  const priorityWikidataTmdbIds = [];
  const otherWikidataTmdbIds = [];

  for (const genreCode of allGenreCodes) {
    const movies = genresWithDetails[genreCode] || [];
    movies.forEach((movie, index) => {
      const tmdbId = movie.tmdbId;
      if (tmdbId) {
        if (index < MOVIES_PER_GENRE) {
          priorityWikidataTmdbIds.push(tmdbId);
        } else {
          otherWikidataTmdbIds.push(tmdbId);
        }
      }
    });
  }

  // Fetch priority movies first, then others
  const allTmdbIds = [...priorityWikidataTmdbIds, ...otherWikidataTmdbIds];
  console.log(`  ‚Üí Checking ${allTmdbIds.length} movies (${priorityWikidataTmdbIds.length} priority, ${otherWikidataTmdbIds.length} overflow)`);

  // Batch queries (50 IDs per query to stay under URL limits)
  const batchSize = 50;
  const streamingOriginalsMap = new Map();

  for (let i = 0; i < allTmdbIds.length; i += batchSize) {
    const batch = allTmdbIds.slice(i, i + batchSize);
    console.log(`  ‚Üí Batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(allTmdbIds.length / batchSize)}: ${batch.length} movies`);

    try {
      const results = await wikidata.getStreamingOriginalsBatch(batch);

      // Merge results
      for (const [tmdbId, serviceCode] of results.entries()) {
        streamingOriginalsMap.set(tmdbId, serviceCode);
      }

      console.log(`    ‚úì Found ${results.size} streaming originals in this batch`);

      // Rate limit: 1 second between queries
      if (i + batchSize < allTmdbIds.length) {
        await WikidataClient.rateLimit();
      }

    } catch (error) {
      console.error(`    ‚úó Batch failed: ${error.message}`);
    }
  }

  console.log(`\nüéØ Wikidata results: ${streamingOriginalsMap.size} streaming originals found`);
  console.log(`üìä Wikidata API requests: ${wikidata.getRequestCount()}`);

  // Show breakdown by service
  const serviceCounts = {};
  for (const serviceCode of streamingOriginalsMap.values()) {
    serviceCounts[serviceCode] = (serviceCounts[serviceCode] || 0) + 1;
  }
  console.log('\nüìä Streaming Originals Breakdown:');
  for (const [serviceCode, count] of Object.entries(serviceCounts).sort((a, b) => b[1] - a[1])) {
    const serviceName = STREAMING_SERVICES[serviceCode]?.name || serviceCode;
    console.log(`  ${serviceName}: ${count} movies`);
  }

  // Save updated Wikidata cache back to Netlify Blobs
  if (wikidata.getNewStreamingOriginals().size > 0) {
    console.log(`\nüíæ Saving ${wikidata.getNewStreamingOriginals().size} new streaming originals to cache...`);
    const mergedStreamingCache = WikidataClient.mergeCaches(persistentStreamingCache, wikidata.getNewStreamingOriginals());
    await store.setJSON('wikidata-streaming', mergedStreamingCache);
    console.log(`  ‚úì Wikidata streaming originals cache updated (total: ${Object.keys(mergedStreamingCache).length} movies)`);
  } else {
    console.log('\nüíæ No new streaming originals to save (all from cache)');
  }

  // STEP 6: Add streaming originals badges to poster URLs
  console.log('\nüè∑Ô∏è  Adding streaming original badges to posters...');

  // Get Netlify site URL from environment (defaults to placeholder for local dev)
  const siteUrl = process.env.URL || process.env.DEPLOY_URL || 'https://your-addon.netlify.app';

  for (const genreCode of allGenreCodes) {
    const movies = genresWithDetails[genreCode] || [];

    for (const movie of movies) {
      // Extract TMDB ID from movie.id (format: "tmdb:12345" or "tt1234567")
      let tmdbId = null;
      if (movie.id.startsWith('tmdb:')) {
        tmdbId = parseInt(movie.id.replace('tmdb:', ''), 10);
      }
      // If it's an IMDB ID, we need to look it up in our original data
      // For now, we'll skip IMDB IDs since we have TMDB IDs from the fetch

      if (tmdbId && streamingOriginalsMap.has(tmdbId)) {
        const serviceCode = streamingOriginalsMap.get(tmdbId);
        const serviceName = STREAMING_SERVICES[serviceCode]?.name || serviceCode;

        // Store streaming original info (for reference/debugging)
        movie.streamingOriginal = {
          service: serviceCode,
          serviceName: serviceName
        };

        // Modify poster URL to use our badge overlay function
        // Works with both TMDB and Fanart.tv URLs
        if (movie.poster) {
          const posterUrl = encodeURIComponent(movie.poster);
          movie.poster = `${siteUrl}/.netlify/functions/poster?url=${posterUrl}&badge=${serviceCode}`;
        }
      }
    }
  }

  const moviesWithBadges = Object.values(genresWithDetails)
    .flat()
    .filter(m => m.streamingOriginal).length;
  console.log(`  ‚úì Added badges to ${moviesWithBadges} streaming original posters`);

  // STEP 7: Store in Netlify Blobs

  // Save FULL CACHE (all fetched movies for rotation pool)
  const fullCacheData = {
    genres: genresWithDetails,
    strategy: 'SIMPLE_POPULAR',
    updatedAt: new Date().toISOString()
  };

  const totalMovies = Object.values(genresWithDetails)
    .reduce((sum, movies) => sum + movies.length, 0);

  console.log('\nüíæ Storing catalog data...');

  await store.setJSON('catalog-full-cache', fullCacheData);
  console.log(`  ‚úì Full cache saved (${totalMovies} total movies across all genres)`);

  // Create DISPLAY CATALOG (top 100 per genre for Stremio)
  const displayGenres = {};
  for (const genreCode of allGenreCodes) {
    const allMovies = genresWithDetails[genreCode] || [];
    // Take top 100 by weighted score (already sorted)
    displayGenres[genreCode] = allMovies.slice(0, MOVIES_PER_GENRE);
  }

  const catalogData = {
    genres: displayGenres,
    strategy: 'SIMPLE_POPULAR',
    updatedAt: new Date().toISOString()
  };

  const displayTotal = Object.values(displayGenres)
    .reduce((sum, movies) => sum + movies.length, 0);

  await store.setJSON('catalog', catalogData);
  console.log(`  ‚úì Display catalog saved (${displayTotal} movies = top ${MOVIES_PER_GENRE} per genre)`);

  const metadata = {
    updatedAt: new Date().toISOString(),
    strategy: omdb ? 'IMDB_WEIGHTED' : 'SIMPLE_POPULAR',
    genreCount: Object.keys(genresWithDetails).length,
    totalMovies,
    streamingOriginals: streamingOriginalsMap.size,
    imdbRatings: imdbRatingsMap.size,
    apiRequests: tmdb.getRequestCount(),
    wikidataRequests: wikidata.getRequestCount(),
    omdbRequests: omdb ? omdb.getRequestCount() : 0
  };

  await store.setJSON('metadata', metadata);
  console.log('  ‚úì Metadata saved');

  // Summary
  console.log('\n‚úÖ Update complete!');
  console.log('‚îÅ'.repeat(50));
  console.log(`üìÖ Date: ${new Date().toISOString()}`);
  console.log(`üéØ Strategy: ${omdb ? 'IMDB_WEIGHTED (all-time popular by IMDb ratings)' : 'SIMPLE_POPULAR (by TMDB popularity)'}`);
  console.log(`üé¨ Total movies in cache: ${totalMovies}`);
  console.log(`üé¨ Total movies in display catalog: ${displayTotal} (top ${MOVIES_PER_GENRE} per genre)`);
  console.log(`‚≠ê IMDb ratings: ${imdbRatingsMap.size}`);
  console.log(`üåê Streaming originals: ${streamingOriginalsMap.size}`);
  console.log(`üìÅ Genres: ${Object.keys(genresWithDetails).length}`);
  console.log(`üîó TMDB API requests: ${tmdb.getRequestCount()}`);
  if (omdb) console.log(`üîó OMDb API requests: ${omdb.getRequestCount()}`);
  console.log(`üîó Wikidata API requests: ${wikidata.getRequestCount()}`);
  console.log('‚îÅ'.repeat(50));

  // Show genre breakdown
  console.log('\nüìä Genre Breakdown (Full Cache):');
  for (const genreCode of allGenreCodes) {
    const cacheCount = genresWithDetails[genreCode].length;
    const displayCount = displayGenres[genreCode].length;
    const status = cacheCount >= MOVIES_PER_GENRE ? '‚úÖ' : cacheCount >= 50 ? '‚ö†Ô∏è ' : '‚ùå';
    console.log(`  ${status} ${GENRES[genreCode].name}: ${cacheCount} cached / ${displayCount} displayed`);
  }
}

// Run the update
runUpdate()
  .then(() => {
    console.log('\nüéâ Nightly update finished successfully!');
    process.exit(0);
  })
  .catch(error => {
    console.error('\n‚ùå Update failed:', error);
    console.error(error.stack);
    process.exit(1);
  });
